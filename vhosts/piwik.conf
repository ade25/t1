# vhost: ${sites:static1} - static1

server {
    listen *:${ports:http};
    server_name www.${hosts:static1} ${hosts:static1};
    return 301 $scheme://${hosts:static2}$request_uri;
}

server {    
    listen *:${ports:http};
    server_name ${hosts:static2};
    access_log ${buildout:directory}/var/log/${hosts:static2}.log;
    error_log ${buildout:directory}/var/log/${hosts:static2}_error.log;
    root ${static-locations:static1};
    index index.php;

    ## Try all locations and relay to index.php as a fallback.
    location / {
    
        ## Disallow any usage of piwik assets if referer is non valid.
        location ~* ^.+\.(?:css|gif|html?|jpe?g|js|png|swf)$ {
            ## Defining the valid referers.
            # valid_referers none blocked *.mysite.com othersite.com;
            # if ($invalid_referer)  {
            #     return 444;
            # }
            expires max;
            ## No need to bleed constant updates. Send the all shebang in one
            ## fell swoop.
            tcp_nodelay off;
            ## Set the OS file cache.
            open_file_cache max=500 inactive=120s;
            open_file_cache_valid 45s;
            open_file_cache_min_uses 2;
            open_file_cache_errors off;
        }
    
        ## Do not serve HTML files from the /tmp folder.
        location ~* ^/tmp/.*\.html?$ {
            return 404;
        }
    
        ## Redirect to the root if attempting to access a txt file.
        location ~* (?:DESIGN|(?:gpl|README|LICENSE)[^.]*|LEGALNOTICE)(?:\.txt)*$ {
            return 404;
        }
    
        ## Disallow access to several helper files.
        location ~* \.(?:bat|git|ini|sh|svn[^.]*|txt|tpl|xml)$ {
            return 404;
        }
    
        try_files $uri /index.php?$query_string;
    }
    
    ## Support for favicon. Return a 1x1 transparent GIF it it doesn't
    ## exist.  doesn't exist.
    location = /favicon.ico {
        try_files /favicon.ico @empty;
    }
    
    location @empty {
        empty_gif;
    }
    
    ## Relay all index.php requests to fastcgi.
    location = /index.php {
        fastcgi_pass phpcgi;
        ## FastCGI cache.
        ## cache ui for 5m (set the same interval of your crontab)
        ## The cache zone referenced.
        fastcgi_cache fcgicache;
        ## The cache key.
        fastcgi_cache_key $host$request_uri;
        
        ## For 200 and 301 make the cache valid for 5 minutes.
        fastcgi_cache_valid 200 301 5m;
        ## For 302 make it valid for 3 minutes.
        fastcgi_cache_valid 302 3m;
        ## For 404 make it valid 1 minute.
        fastcgi_cache_valid 404 1m;
        ## If there are any upstream errors or the item has expired use
        ## whatever it is available.
        fastcgi_cache_use_stale error timeout invalid_header updating http_500;
        ## The Cache-Control and Expires headers should be delivered untouched
        ## from the upstream to the client.
        fastcgi_ignore_headers Cache-Control Expires;
        ## If we have a cookie we should bypass the cache. The same if we have a
        fastcgi_cache_bypass $no_cache;
        fastcgi_no_cache $no_cache;
        ## Add a cache miss/hit status header.
        add_header X-Piwik-Cache $upstream_cache_status;
        ## To avoid any interaction with the cache control headers we expire
        ## everything on this location immediately.
        expires epoch;
    }
    
    ## Relay all piwik.php requests to fastcgi.
    location = /piwik.php {
        fastcgi_pass phpcgi;
        # -*- mode: nginx; mode: flyspell-prog;  ispell-local-dictionary: "american" -*-
        
        ### Implementation of the microcache concept as presented here:
        ### http://fennb.com/microcaching-speed-your-app-up-250x-with-no-n
        
        ## The cache zone referenced.
        fastcgi_cache fcgicache;
        ## The cache key.
        fastcgi_cache_key $host$request_uri;
        
        ## For 200 and 301 make the cache valid for 2 hours.
        fastcgi_cache_valid 200 301 2h;
        ## For 302 make it valid for 30 minutes.
        fastcgi_cache_valid 302 30m;
        ## For 404 make it valid 10 minutes.
        fastcgi_cache_valid 404 10m;
        ## If there are any upstream errors or the item has expired use
        ## whatever it is available.
        fastcgi_cache_use_stale error timeout invalid_header updating http_500;
        ## The Cache-Control and Expires headers should be delivered untouched
        ## from the upstream to the client.
        fastcgi_ignore_headers Cache-Control Expires;
        ## If we have a cookie we should bypass the cache. The same if we have a
        fastcgi_cache_bypass $no_cache;
        fastcgi_no_cache $no_cache;
        ## Add a cache miss/hit status header.
        add_header X-Piwik-Long-Cache $upstream_cache_status;
        ## To avoid any interaction with the cache control headers we expire
        ## everything on this location immediately.
        expires epoch;

    }
    
    ## Any other attempt to access PHP files returns a 404.
    location ~* ^.+\.php$ {
        return 404;
    }
    
    ## No crawling of this site for bots that obey robots.txt.
    location = /robots.txt {
        return 200 "User-agent: *\nDisallow: /\n";
    }
    
    ## Including the php-fpm status and ping pages config.
    ## Uncomment to enable if you're running php-fpm.
    #include php_fpm_status_vhost.conf;


}